# Define variables and default images
variables:
    NODE_IMAGE: node:alpine
    DOCKER_IMAGE: docker:24.0.5
    PROJECT_NAME: portfolio-dashboard
    GITLAB_API_URL: "https://gitlab.com/api/v4"
    GITLAB_PROJECT_ID: $CI_PROJECT_ID

# Define the stages
stages:
    - always_run
    - documentation
    - test
    - build
    - release
    - deploy
    - merge

# Always run pipeline so that when no pipeline is run, the pipeline is still created
always_run:
    stage: always_run
    script:
        - echo "This is a dummy job to ensure the pipeline is always run"
    rules:
        # Run when other requirements are not met
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "production" && $CI_COMMIT_BRANCH != "pre-production" && $CI_COMMIT_BRANCH !~ /^feature\/.*$/ && $CI_COMMIT_BRANCH !~ /^fix\/.*$/ && $CI_COMMIT_BRANCH !~ /^docs\/.*$/

# Lint the code
lint_code:
    stage: test
    image: $NODE_IMAGE
    script:
        - npm install
        - npm run lint
    except:
        - main
        - production
        - pre-production

# Run unit tests
unit_tests:
    stage: test
    image: $NODE_IMAGE
    script:
        - npm install
        - npm test
    except:
        - main
        - production
        - pre-production

# Deploy the documentation
deploy_documentation:
    stage: documentation
    script:
        - echo "This is where I would deploy the documentation once configured"
    only:
        - main

# Build the project for testing
build_project:
    stage: build
    image: $DOCKER_IMAGE
    services:
        - docker:24.0.5-dind
    script:
        - docker build -t $PROJECT_NAME:testing .
    rules:
        - if: $CI_COMMIT_BRANCH == "main"

# Merge the main branch into the pre-production branch
create_merge_request_main_to_preprod:
    stage: merge
    image: alpine:latest
    script:
        - apk add --no-cache curl jq
        - |
            existing_mr=$(curl --header "PRIVATE-TOKEN: $GITLAB_PRIVATE_TOKEN" \
              "$GITLAB_API_URL/projects/$GITLAB_PROJECT_ID/merge_requests?source_branch=main&target_branch=pre-production&state=opened" \
              | jq '. | length')
            if [ "$existing_mr" -eq "0" ]; then
              curl --request POST --header "PRIVATE-TOKEN: $GITLAB_PRIVATE_TOKEN" \
                "$GITLAB_API_URL/projects/$GITLAB_PROJECT_ID/merge_requests" \
                --data "source_branch=main" \
                --data "target_branch=pre-production" \
                --data "title=Merge main into pre-production" \
                --data "description=Automated merge request from main to pre-production"
            else
              echo "Merge request from main to pre-production already exists."
            fi
    rules:
        - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"

# Get the project version for release
get_release_version:
    stage: release
    image: node:23-alpine
    script:
        # Check to see if project tag already exists
        - |
            if docker manifest inspect "$DOCKER_USER/$PROJECT_NAME:$TAG" > /dev/null 2>&1; then
                echo "Docker image $DOCKER_USER/$PROJECT_NAME:$TAG already exists."
                exit 1
            else
                echo "Docker image $DOCKER_USER/$PROJECT_NAME:$TAG does not exist, passing tag to next job."
            fi

        # Get the project version
        - export VERSION=$(node -p "require('./package.json').version")
        - echo "VERSION=$VERSION" >> variables.env
    artifacts:
        reports:
            dotenv: variables.env
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"

# Build the project for release
build_release:
    needs:
        - job: get_release_version
          artifacts: true
    stage: release
    image: $DOCKER_IMAGE
    services:
        - docker:24.0.5-dind
    variables:
        DOCKER_DRIVER: overlay2
        DOCKER_BUILDKIT: 1
        DOCKER_CLI_EXPERIMENTAL: enabled
    before_script:
        - echo "$DOCKER_PASSWORD" | docker login -u $DOCKER_USER --password-stdin
    script:
        - docker buildx create --use
        - docker buildx build --platform linux/amd64,linux/arm64 -t $DOCKER_USER/$PROJECT_NAME:$VERSION -t $DOCKER_USER/$PROJECT_NAME:latest --push .
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"

# TODO: Automatically generate release notes
create_release_notes:
    stage: release
    script:
        - git log --oneline $(git describe --tags --abbrev=0 || git rev-list --max-parents=0 HEAD)...HEAD | tr '\n' '\7' | sed 's/\x7/\n\n/g' >> release.md
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"
    artifacts:
        paths:
            - release.md

# Create a release
create_release:
    needs:
        - job: get_release_version
          artifacts: true
        - job: build_release
    stage: release
    image: registry.gitlab.com/gitlab-org/release-cli:latest
    script:
        - echo "Creating release $VERSION"
    release:
        name: Version $VERSION
        tag_name: $VERSION
        description: release.md
        ref: $CI_COMMIT_SHA
        assets:
            links:
                - name: "Docker Image"
                  url: https://hub.docker.com/r/$DOCKER_USER/portfolio-dashboard
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"

# Get the proejct version for deployment
get_deploy_version:
    stage: deploy
    image: node:23-alpine
    script:
        - export VERSION=$(node -p "require('./package.json').version")
        - echo "VERSION=$VERSION" >> variables.env
    artifacts:
        reports:
            dotenv: variables.env
    rules:
        - if: $CI_COMMIT_BRANCH == "production"
# TODO: Use kubernetes spec to deploy to production environment
