# Define variables and default images
variables:
    NODE_IMAGE: node:alpine
    DOCKER_IMAGE: docker:24.0.5
    PROJECT_NAME: portfolio-dashboard
    GITLAB_API_URL: "https://gitlab.com/api/v4"
    GITLAB_PROJECT_ID: $CI_PROJECT_ID

# Define the stages
stages:
    - always_run
    - documentation
    - test
    - build
    - release
    - deploy
    - merge

# Always run pipeline so that when no pipeline is run, the pipeline is still created
always_run:
    stage: always_run
    script:
        - echo "This is a dummy job to ensure the pipeline is always run"
    rules:
        # Run when other requirements are not met
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "production" && $CI_COMMIT_BRANCH != "pre-production" && $CI_COMMIT_BRANCH !~ /^feature\/.*$/ && $CI_COMMIT_BRANCH !~ /^fix\/.*$/ && $CI_COMMIT_BRANCH !~ /^docs\/.*$/

# Lint the code
lint_code:
    stage: test
    image: $NODE_IMAGE
    script:
        - npm install
        - npm run lint
    rules:
        - if: $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "production" && $CI_COMMIT_BRANCH != "pre-production"

# Run unit tests
unit_tests:
    stage: test
    image: $NODE_IMAGE
    script:
        - npm install
        - npm test
    rules:
        - if: $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "production" && $CI_COMMIT_BRANCH != "pre-production"

# Deploy the documentation
deploy_documentation:
    stage: documentation
    script:
        - echo "This is where I would deploy the documentation once configured"
    only:
        - main

# Build the project for testing
build_project:
    stage: build
    image: $DOCKER_IMAGE
    services:
        - docker:24.0.5-dind
    script:
        - docker build -t $PROJECT_NAME:testing .
    rules:
        - if: $CI_COMMIT_BRANCH == "main"

# Change the package.json version to the tag version
change_package_version:
    stage: merge
    image: $NODE_IMAGE
    script:
        - npm version $CI_COMMIT_TAG
        - git push --follow-tags
    rules:
        - if: $CI_COMMIT_TAG

# Merge the main branch into the pre-production branch
create_merge_request_main_to_preprod:
    needs:
        - job: change_package_version
    stage: merge
    before_script:
        - apt-get update -y && apt-get install -y jq
    script:
        - sh .gitlab/scripts/merge-to-pre-prod.sh
    rules:
        - if: $CI_COMMIT_TAG && $CI_COMMIT_BRANCH == "main"

# Get the project version for release
get_release_version:
    stage: release
    image: node:23-alpine
    script:
        # Check to see if project tag already exists
        - |
            if docker manifest inspect "$DOCKER_USER/$PROJECT_NAME:$TAG" > /dev/null 2>&1; then
                echo "Docker image $DOCKER_USER/$PROJECT_NAME:$TAG already exists."
                exit 1
            else
                echo "Docker image $DOCKER_USER/$PROJECT_NAME:$TAG does not exist, passing tag to next job."
            fi

        # Get the project version
        - export VERSION=$(node -p "require('./package.json').version")
        - echo "VERSION=$VERSION" >> variables.env
    artifacts:
        reports:
            dotenv: variables.env
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"

# Build the project for release
build_release:
    needs:
        - job: get_release_version
          artifacts: true
    stage: release
    image: $DOCKER_IMAGE
    services:
        - docker:24.0.5-dind
    variables:
        DOCKER_DRIVER: overlay2
        DOCKER_BUILDKIT: 1
        DOCKER_CLI_EXPERIMENTAL: enabled
    before_script:
        - echo "$DOCKER_PASSWORD" | docker login -u $DOCKER_USER --password-stdin
    script:
        - docker buildx create --use
        - docker buildx build --platform linux/amd64,linux/arm64 -t $DOCKER_USER/$PROJECT_NAME:$VERSION -t $DOCKER_USER/$PROJECT_NAME:latest --push .
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"

# Automatically generate release notes
create_release_notes:
    stage: release
    script:
        - git log --oneline $(git describe --tags --abbrev=0 || git rev-list --max-parents=0 HEAD)...HEAD | tr '\n' '\7' | sed 's/\x7/\n\n/g' >> release.md
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"
    artifacts:
        paths:
            - release.md

# Create a release
create_release:
    needs:
        - job: get_release_version
          artifacts: true
        - job: build_release
    stage: release
    image: registry.gitlab.com/gitlab-org/release-cli:latest
    script:
        - echo "Creating release $VERSION"
    release:
        name: Version $VERSION
        tag_name: $VERSION
        description: release.md
        ref: $CI_COMMIT_SHA
        assets:
            links:
                - name: "Docker Image"
                  url: https://hub.docker.com/r/$DOCKER_USER/portfolio-dashboard
    rules:
        - if: $CI_COMMIT_BRANCH == "pre-production"

# Merge the main branch into the pre-production branch
create_merge_request_preprod_to_prod:
    needs:
        - job: create_release
    stage: merge
    before_script:
        - apt-get update -y && apt-get install -y jq
    script:
        - sh .gitlab/scripts/merge-to-prod.sh

# Get the proejct version for deployment
get_deploy_version:
    stage: deploy
    image: node:23-alpine
    script:
        - export VERSION=$(node -p "require('./package.json').version")
        - echo "VERSION=$VERSION" >> variables.env
    artifacts:
        reports:
            dotenv: variables.env
    rules:
        - if: $CI_COMMIT_BRANCH == "production"
# TODO: Use kubernetes spec to deploy to production environment
